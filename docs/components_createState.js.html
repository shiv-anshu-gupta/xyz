

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title> components/createState.js</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- build/entry.js removed - not needed -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    Documentation
                </a>
                
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Modules</h3><ul><li><a href="module-Context_ThemeContext.html">Context/ThemeContext</a></li><li><a href="module-analyzeGroupsAndPublish.html">analyzeGroupsAndPublish</a></li><li><a href="module-axisBuilder.html">axisBuilder</a></li><li><a href="module-axisCalculator.html">axisCalculator</a></li><li><a href="module-calculateAndPublishMaxYAxes.html">calculateAndPublishMaxYAxes</a></li><li><a href="module-chartAxisAlignment.html">chartAxisAlignment</a></li><li><a href="module-chartComponent.html">chartComponent</a></li><li><a href="module-chartManager.html">chartManager</a></li><li><a href="module-chartUpdateHelpers.html">chartUpdateHelpers</a></li><li><a href="module-components_AnalysisSidebar.html">components/AnalysisSidebar</a></li><li><a href="module-components_ChannelList.html">components/ChannelList</a></li><li><a href="module-components_ComputedChannelsSidebar.html">components/ComputedChannelsSidebar</a></li><li><a href="module-components_DeltaDrawer.html">components/DeltaDrawer</a></li><li><a href="module-components_DeltaTable.html">components/DeltaTable</a></li><li><a href="module-components_DeltaTableDataFormatter.html">components/DeltaTableDataFormatter</a></li><li><a href="module-components_DeltaTableRenderer.html">components/DeltaTableRenderer</a></li><li><a href="module-components_EquationEvaluatorInChannelList.html">components/EquationEvaluatorInChannelList</a></li><li><a href="module-components_PolarChart.html">components/PolarChart</a></li><li><a href="module-components_PolarChartCanvas.html">components/PolarChartCanvas</a></li><li><a href="module-components_ProgressBar.html">components/ProgressBar</a></li><li><a href="module-components_ResizableGroup.html">components/ResizableGroup</a></li><li><a href="module-components_SidebarResizer.html">components/SidebarResizer</a></li><li><a href="module-components_Tooltip.html">components/Tooltip</a></li><li><a href="module-components_debugPanelLite.html">components/debugPanelLite</a></li><li><a href="module-components_renderComputedChart.html">components/renderComputedChart</a></li><li><a href="module-components_renderComtradeCharts.html">components/renderComtradeCharts</a></li><li><a href="module-components_renderDigitalCharts.html">components/renderDigitalCharts</a></li><li><a href="module-components_renderSingleAnalogChart.html">components/renderSingleAnalogChart</a></li><li><a href="module-components_renderSingleDigitalChart.html">components/renderSingleDigitalChart</a></li><li><a href="module-components_setupPolarChartIntegration.html">components/setupPolarChartIntegration</a></li><li><a href="module-components_showError.html">components/showError</a></li><li><a href="module-components_verticalLineControl.html">components/verticalLineControl</a></li><li><a href="module-comtradeUtils.html">comtradeUtils</a></li><li><a href="module-createDragBar.html">createDragBar</a></li><li><a href="module-createState.html">createState</a></li><li><a href="module-domUpdateQueue.html">domUpdateQueue</a></li><li><a href="module-domUpdateQueueInit.html">domUpdateQueueInit</a></li><li><a href="module-eventListenerManager.html">eventListenerManager</a></li><li><a href="module-handleVerticalLineShortcuts.html">handleVerticalLineShortcuts</a></li><li><a href="module-initVerticalLineControl.html">initVerticalLineControl</a></li><li><a href="module-main.html">main</a></li><li><a href="module-maxYAxesStore.html">maxYAxesStore</a></li><li><a href="module-mergerWindowLauncher.html">mergerWindowLauncher</a></li><li><a href="module-plugins_autoUnitScalePlugin.html">plugins/autoUnitScalePlugin</a></li><li><a href="module-plugins_axisLinesPlugin.html">plugins/axisLinesPlugin</a></li><li><a href="module-plugins_deltaBoxPlugin.html">plugins/deltaBoxPlugin</a></li><li><a href="module-plugins_horizontalZoomPanPlugin.html">plugins/horizontalZoomPanPlugin</a></li><li><a href="module-plugins_verticalLinePlugin.html">plugins/verticalLinePlugin</a></li><li><a href="module-seriesMapper.html">seriesMapper</a></li><li><a href="module-services_computedChannels.html">services/computedChannels</a></li><li><a href="module-services_computedChannels_dataPreparation.html">services/computedChannels/dataPreparation</a></li><li><a href="module-services_computedChannels_eventHandling.html">services/computedChannels/eventHandling</a></li><li><a href="module-services_computedChannels_expressionConversion.html">services/computedChannels/expressionConversion</a></li><li><a href="module-services_computedChannels_resultProcessing.html">services/computedChannels/resultProcessing</a></li><li><a href="module-services_computedChannels_stateUpdate.html">services/computedChannels/stateUpdate</a></li><li><a href="module-services_computedChannels_validators.html">services/computedChannels/validators</a></li><li><a href="module-services_computedChannels_workerManagement.html">services/computedChannels/workerManagement</a></li><li><a href="module-setupChartDragAndDrop.html">setupChartDragAndDrop</a></li><li><a href="module-timeInterpolation.html">timeInterpolation</a></li><li><a href="module-utils_autoGroupChannels.html">utils/autoGroupChannels</a></li><li><a href="module-utils_chartDomUtils.html">utils/chartDomUtils</a></li><li><a href="module-utils_chartMetadataStore.html">utils/chartMetadataStore</a></li><li><a href="module-utils_computedChannelMetadata.html">utils/computedChannelMetadata</a></li><li><a href="module-utils_constants.html">utils/constants</a></li><li><a href="module-utils_helpers.html">utils/helpers</a></li><li><a href="module-utils_sidebarStore.html">utils/sidebarStore</a></li><li><a href="module-workers_computedChannelWorker.html">workers/computedChannelWorker</a></li></ul><h3>Classes</h3><ul><li><a href="module-components_PolarChartCanvas.PolarChartCanvas.html">PolarChartCanvas</a></li><li><a href="module-utils_computedChannelMetadata-ComputedChannelMetadata.html">ComputedChannelMetadata</a></li></ul><h3>Global</h3><ul><li><a href="global.html#IMPLEMENTATION_COMPLETE">IMPLEMENTATION_COMPLETE</a></li><li><a href="global.html#QUICK_REFERENCE">QUICK_REFERENCE</a></li><li><a href="global.html#STORAGE_CFG_KEY">STORAGE_CFG_KEY</a></li><li><a href="global.html#ZOOM_ICONS">ZOOM_ICONS</a></li><li><a href="global.html#adjustMainContent">adjustMainContent</a></li><li><a href="global.html#appendComputedChannelToStorage">appendComputedChannelToStorage</a></li><li><a href="global.html#applyZoom">applyZoom</a></li><li><a href="global.html#attachChartContainer">attachChartContainer</a></li><li><a href="global.html#attachChartEventHandlers">attachChartEventHandlers</a></li><li><a href="global.html#attachChartPlugins">attachChartPlugins</a></li><li><a href="global.html#attachComputedChartContainer">attachComputedChartContainer</a></li><li><a href="global.html#attachComputedChartEventHandlers">attachComputedChartEventHandlers</a></li><li><a href="global.html#attachComputedChartPlugins">attachComputedChartPlugins</a></li><li><a href="global.html#broadcastComputedChannelChange">broadcastComputedChannelChange</a></li><li><a href="global.html#buildChartData">buildChartData</a></li><li><a href="global.html#buildChartOptions">buildChartOptions</a></li><li><a href="global.html#buildComputedChannelLabels">buildComputedChannelLabels</a></li><li><a href="global.html#buildComputedChartOptions">buildComputedChartOptions</a></li><li><a href="global.html#buildGroupsWithAutoGrouping">buildGroupsWithAutoGrouping</a></li><li><a href="global.html#buildGroupsWithUserAssignments">buildGroupsWithUserAssignments</a></li><li><a href="global.html#buildUnitChartData">buildUnitChartData</a></li><li><a href="global.html#calculateStats">calculateStats</a></li><li><a href="global.html#chart2">chart2</a></li><li><a href="global.html#cleanupOldComputedCharts">cleanupOldComputedCharts</a></li><li><a href="global.html#clearChartsContainer">clearChartsContainer</a></li><li><a href="global.html#clearComputedChannelsFromStorage">clearComputedChannelsFromStorage</a></li><li><a href="global.html#clearExpressionCache">clearExpressionCache</a></li><li><a href="global.html#closeAnalysisDrawer">closeAnalysisDrawer</a></li><li><a href="global.html#collectChartDeltas">collectChartDeltas</a></li><li><a href="global.html#computeChartDataDimensions">computeChartDataDimensions</a></li><li><a href="global.html#createBinaryBlob">createBinaryBlob</a></li><li><a href="global.html#createChannelList">createChannelList</a></li><li><a href="global.html#createChartMetadata">createChartMetadata</a></li><li><a href="global.html#createChartOptions">createChartOptions</a></li><li><a href="global.html#createComputedChartMetadata">createComputedChartMetadata</a></li><li><a href="global.html#createComputedClickHandler">createComputedClickHandler</a></li><li><a href="global.html#createComputedMousemoveHandler">createComputedMousemoveHandler</a></li><li><a href="global.html#createDigitalFillPlugin">createDigitalFillPlugin</a></li><li><a href="global.html#createGroupDragBar">createGroupDragBar</a></li><li><a href="global.html#createMousemoveHandler">createMousemoveHandler</a></li><li><a href="global.html#createScopeTemplate">createScopeTemplate</a></li><li><a href="global.html#createState">createState</a></li><li><a href="global.html#createVerticalLineClickHandler">createVerticalLineClickHandler</a></li><li><a href="global.html#createZoomControlsHTML">createZoomControlsHTML</a></li><li><a href="global.html#debounce">debounce</a></li><li><a href="global.html#deleteComputedChannelFromStorage">deleteComputedChannelFromStorage</a></li><li><a href="global.html#encodeFloat64">encodeFloat64</a></li><li><a href="global.html#encodeInt32">encodeInt32</a></li><li><a href="global.html#evaluateExpression">evaluateExpression</a></li><li><a href="global.html#exportAllChannelsAsCSV">exportAllChannelsAsCSV</a></li><li><a href="global.html#exportComputedChannelsAsCSV">exportComputedChannelsAsCSV</a></li><li><a href="global.html#extractChannelMetadata">extractChannelMetadata</a></li><li><a href="global.html#extractChannelNameFromEquation">extractChannelNameFromEquation</a></li><li><a href="global.html#extractGroupId">extractGroupId</a></li><li><a href="global.html#extractMathExpression">extractMathExpression</a></li><li><a href="global.html#filterGroupsWithChannels">filterGroupsWithChannels</a></li><li><a href="global.html#filterUnassignedComputedChannels">filterUnassignedComputedChannels</a></li><li><a href="global.html#filterValidIndices">filterValidIndices</a></li><li><a href="global.html#formatEquationForLatex">formatEquationForLatex</a></li><li><a href="global.html#formatScaledValue">formatScaledValue</a></li><li><a href="global.html#generateCFGContentBinary32">generateCFGContentBinary32</a></li><li><a href="global.html#generateCFGContentBinary64">generateCFGContentBinary64</a></li><li><a href="global.html#generateCFGContentFloat32">generateCFGContentFloat32</a></li><li><a href="global.html#generateCFGContentFloat64">generateCFGContentFloat64</a></li><li><a href="global.html#generateDATContentBinary32">generateDATContentBinary32</a></li><li><a href="global.html#generateDATContentBinary64">generateDATContentBinary64</a></li><li><a href="global.html#generateDATContentFloat32">generateDATContentFloat32</a></li><li><a href="global.html#generateDATContentFloat64">generateDATContentFloat64</a></li><li><a href="global.html#getCacheStats">getCacheStats</a></li><li><a href="global.html#getChannelByDisplayName">getChannelByDisplayName</a></li><li><a href="global.html#getChannelMetadata">getChannelMetadata</a></li><li><a href="global.html#getChannelsForFile">getChannelsForFile</a></li><li><a href="global.html#getCompiledExpression">getCompiledExpression</a></li><li><a href="global.html#getComputedChannelById">getComputedChannelById</a></li><li><a href="global.html#getComputedChannelStorageMetadata">getComputedChannelStorageMetadata</a></li><li><a href="global.html#getComputedChannelsState">getComputedChannelsState</a></li><li><a href="global.html#getElementWidth">getElementWidth</a></li><li><a href="global.html#getFileIndexForTime">getFileIndexForTime</a></li><li><a href="global.html#getOriginalChannelName">getOriginalChannelName</a></li><li><a href="global.html#getSampleIndexInFile">getSampleIndexInFile</a></li><li><a href="global.html#getZoomLevel">getZoomLevel</a></li><li><a href="global.html#groupChannelsByUnit">groupChannelsByUnit</a></li><li><a href="global.html#handleComputedVerticalLineAddition">handleComputedVerticalLineAddition</a></li><li><a href="global.html#handleVerticalLineAddition">handleVerticalLineAddition</a></li><li><a href="global.html#hasStoredComputedChannels">hasStoredComputedChannels</a></li><li><a href="global.html#initComputedChannelsState">initComputedChannelsState</a></li><li><a href="global.html#initializeChartInstance">initializeChartInstance</a></li><li><a href="global.html#initializeComputedChartInstance">initializeComputedChartInstance</a></li><li><a href="global.html#initializeSidebarChannels">initializeSidebarChannels</a></li><li><a href="global.html#initializeZoomControls">initializeZoomControls</a></li><li><a href="global.html#injectZoomControls">injectZoomControls</a></li><li><a href="global.html#isMathJaxLoaded">isMathJaxLoaded</a></li><li><a href="global.html#listenForComputedChannelChanges">listenForComputedChannelChanges</a></li><li><a href="global.html#loadComputedChannelsForGroup">loadComputedChannelsForGroup</a></li><li><a href="global.html#loadComputedChannelsFromStorage">loadComputedChannelsFromStorage</a></li><li><a href="global.html#loadMathJax">loadMathJax</a></li><li><a href="global.html#mathJaxPromise">mathJaxPromise</a></li><li><a href="global.html#measurePerformance">measurePerformance</a></li><li><a href="global.html#mergeAnalogAndComputedMetadata">mergeAnalogAndComputedMetadata</a></li><li><a href="global.html#mergeAnalogChannels">mergeAnalogChannels</a></li><li><a href="global.html#mergeComtradeFilesSetsSequential">mergeComtradeFilesSetsSequential</a></li><li><a href="global.html#mergeDigitalChannels">mergeDigitalChannels</a></li><li><a href="global.html#mergeTimeArraysSequential">mergeTimeArraysSequential</a></li><li><a href="global.html#openAnalysisDrawer">openAnalysisDrawer</a></li><li><a href="global.html#openBothSidebars">openBothSidebars</a></li><li><a href="global.html#openDeltaWindow">openDeltaWindow</a></li><li><a href="global.html#openPhasorDiagram">openPhasorDiagram</a></li><li><a href="global.html#prepareChartDataContext">prepareChartDataContext</a></li><li><a href="global.html#processEquationInput">processEquationInput</a></li><li><a href="global.html#renameChannelWithPrefix">renameChannelWithPrefix</a></li><li><a href="global.html#renderChannelLabelContainer">renderChannelLabelContainer</a></li><li><a href="global.html#renderComputedChannels">renderComputedChannels</a></li><li><a href="global.html#renderLatex">renderLatex</a></li><li><a href="global.html#resetZoom">resetZoom</a></li><li><a href="global.html#resizeChartsToContainers">resizeChartsToContainers</a></li><li><a href="global.html#resolveGroupIndices">resolveGroupIndices</a></li><li><a href="global.html#resolveTimeArray">resolveTimeArray</a></li><li><a href="global.html#saveComputedChannelsToStorage">saveComputedChannelsToStorage</a></li><li><a href="global.html#setZoomLevel">setZoomLevel</a></li><li><a href="global.html#setupMobileSidebar">setupMobileSidebar</a></li><li><a href="global.html#showChannelListWindow">showChannelListWindow</a></li><li><a href="global.html#showFileInfo">showFileInfo</a></li><li><a href="global.html#subscribeChartUpdates">subscribeChartUpdates</a></li><li><a href="global.html#syncComputedChannelsWithParent">syncComputedChannelsWithParent</a></li><li><a href="global.html#toggleChartsVisibility">toggleChartsVisibility</a></li><li><a href="global.html#updateComputedChannelGroupInStorage">updateComputedChannelGroupInStorage</a></li><li><a href="global.html#updateComputedChannelInStorage">updateComputedChannelInStorage</a></li><li><a href="global.html#updateFileInfo">updateFileInfo</a></li><li><a href="global.html#updateMainZoomPosition">updateMainZoomPosition</a></li><li><a href="global.html#updateStatsCards">updateStatsCards</a></li><li><a href="global.html#updateZoomDisplay">updateZoomDisplay</a></li><li><a href="global.html#validateChannelName">validateChannelName</a></li><li><a href="global.html#validateGroupIndices">validateGroupIndices</a></li><li><a href="global.html#wrapChartInSection">wrapChartInSection</a></li><li><a href="global.html#zoomIn">zoomIn</a></li><li><a href="global.html#zoomOut">zoomOut</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>components/createState.js</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @file createState.js
 * @module createState
 * @description
 * High-performance, deeply reactive state management system for vanilla JavaScript applications.
 * Provides observable state with path-based and selector-based subscriptions, batched updates,
 * computed properties, middleware support, DOM binding capabilities, and full undo/redo history.
 *
 * @example
 * // Create reactive state
 * const state = createState({ user: { name: "Alice", city: "Paris" } });
 * state.user.name = "Bob"; // Triggers all subscribers
 *
 * // Subscribe to changes
 * state.subscribe(change => {
 *   console.log("Changed:", change.path, change.newValue);
 * });
 *
 * // Subscribe to specific path
 * state.subscribe(change => {
 *   console.log("User changed:", change.newValue);
 * }, { path: "user" });
 *
 * // Computed property
 * state.computed("fullInfo", ["user.name", "user.city"], s =>
 *   `${s.user.name} from ${s.user.city}`
 * );
 * console.log(state.fullInfo); // "Bob from Paris"
 */

/**
 * @typedef {Object} ChangeObject
 * @property {Array&lt;string|number>} path - Array of keys from root to changed property (e.g., ['user', 'profile', 'city'])
 * @property {*} newValue - The new value of the property after change
 * @property {*} oldValue - The previous value of the property before change
 * @property {string|number} prop - The property key that changed (last element in path)
 * @property {Proxy} root - The root state proxy object (entire state tree)
 * @property {*} [selectorValue] - Optional: value returned by selector function (selector-based subscriptions only)
 *
 * @example
 * // Typical change object structure
 * {
 *   path: ['user', 'profile', 'city'],
 *   newValue: 'London',
 *   oldValue: 'Paris',
 *   prop: 'city',
 *   root: proxyObject,
 *   selectorValue: 'AliceLondon' // only if using selector subscription
 * }
 *
 * * ----------------------------------------------------------------------------
 * FUNCTION SIGNATURES:
 *
 * createState(initialState, options?)
 *   - initialState: object, array, or primitive
 *   - options: { batch?: boolean } (default: true)
 *   => Returns a reactive proxy with API methods.
 *
 * state.subscribe(fn, options?)
 *   - fn: (change) => void
 *   - options: {
 *       path?: string | string[],
 *       descendants?: boolean,
 *       selector?: (state) => any,
 *       batch?: boolean
 *     }
 *   => Subscribes to changes. Path/selector/descendants are optional.
 *
 * state.unsubscribe(fn)
 *   - fn: The original subscriber function passed to subscribe.
 *   => Unsubscribes the function.
 *
 * state.computed(name, dependencies, computeFn)
 *   - name: string (property name for computed value)
 *   - dependencies: array of string paths
 *   - computeFn: (state) => any
 *   => Adds a computed property to the state.
 *
 * state.derived(name, dependencies, computeFn)
 *   - Alias for .computed
 *
 * state.use(middlewareFn)
 *   - middlewareFn: (change) => change | null | undefined | false
 *   => Adds middleware to observe, modify, or block changes.
 *
 * ----------------------------------------------------------------------------
 * CHANGE OBJECT PROPERTIES:
 * - path: Array of keys to the changed property (e.g., ['user','profile','city'])
 * - newValue: New value of the property
 * - oldValue: Previous value of the property
 * - prop: The property key that changed (last in path)
 * - root: The root state proxy
 * - selectorValue: (optional) Value returned by selector function
 *
 * ----------------------------------------------------------------------------
 * NUANCES:
 * - For object/array state: access properties directly (e.g., state.user.name)
 * - For primitive state: use state.value (e.g., const state = createState(5); state.value = 10; console.log(state.value); // 10)
 *
 * ----------------------------------------------------------------------------
 * USAGE EXAMPLES:
 *
 * // 1. Basic usage
 * const state = createState({ user: { name: "Alice", profile: { city: "Paris" } } });
 * state.user.name = "Bob";
 *
 * // 2. Primitive state
 * const num = createState(5);
 * num.value = 10;
 *
 * // 3. Subscribe to all changes
 * state.subscribe(change => {
 *   console.log(change.path, change.newValue, change.oldValue);
 * });
 *
 * // 4. Subscribe to a specific path
 * state.subscribe(change => {
 *   console.log("City changed:", change.newValue);
 * }, { path: "user.profile.city" });
 *
 * // 5. Subscribe to all descendants of a path
 * state.subscribe(change => {
 *   console.log("Profile changed:", change.path, change.newValue);
 * }, { path: "user.profile", descendants: true });
 *
 * // 6. Selector-based subscription
 * state.subscribe(change => {
 *   console.log("Selector value changed:", change.selectorValue);
 * }, { selector: s => s.user.name + s.user.profile.city });
 *
 * // 7. Computed/derived property
 * state.computed("userInfo", ["user.name", "user.profile.city"], s => s.user.name + "@" + s.user.profile.city);
 * // or
 * state.derived("userInfo", ["user.name", "user.profile.city"], s => s.user.name + "@" + s.user.profile.city);
 * console.log(state.userInfo); // e.g., "Bob@Paris"
 *
 * // 8. Middleware: log and block invalid changes
 * state.use(change => {
 *   if (change.prop === "age" &amp;&amp; change.newValue &lt; 0) return null; // block
 *   console.log("Change:", change);
 *   return change;
 * });
 *
 * // 9. Unsubscribe
 * function onChange(change) { ... }
 * state.subscribe(onChange);
 * state.unsubscribe(onChange);
 *
 * ----------------------------------------------------------------------------
 *  API
 *
 * Usage Examples:
 *
 * // 1. Deep reactivity
 * // For object/array state, access properties directly:
 * const state = createState({ user: { name: "Alice" }, items: [1,2,3] });
 * state.user.name = "Bob"; // triggers subscribers
 * state.items.push(4);      // triggers subscribers
 *
 * // For primitive state, use .value:
 * const numState = createState(5);
 * numState.value = 10; // triggers subscribers
 * console.log(numState.value); // 10
 *
 * // 2. Path-based subscriptions
 * state.subscribe(change => { console.log("Any change", change); });
 * state.subscribe(change => { ... }, "user.profile.city");
 * state.subscribe(change => { ... }, ["user", "profile", "city"]);
 * state.subscribe(change => { ... }, { path: "user.profile", descendants: true });
 *
 * // 3. Selector-based subscriptions
 * // The selector function receives the state and returns a derived value.
 * // The subscription is triggered only when the selector's return value changes.
 * state.subscribe(change => {
 *   // change.selectorValue is the new derived value
 *   // change.root is the full state
 *   // You can still read or update state via change.root or the state variable
 *   console.log("Selector value:", change.selectorValue);
 * }, { selector: s => s.user.name + s.user.profile.city });
 *
 * // 4. Batching (default: on, can be disabled per state)
 * const state1 = createState({ value: 0 });
 * state1.subscribe(change => { console.log("Batched:", change.newValue); });
 * state1.value = 1; state1.value = 2; // Only one notification per tick
 * const state2 = createState({ value: 0 }, { batch: false });
 * state2.subscribe(change => { console.log("Immediate:", change.newValue); });
 * state2.value = 1; state2.value = 2; // Notified for each change
 *
 * // 5. Computed/derived properties (syntactic sugar)
 * // Using .computed (existing)
 * state.computed("userInfo", ["user.profile.city", "user.name"], () => {
 *   return state.user.name + "@" + state.user.profile.city;
 * });
 * console.log(state.userInfo); // "Bob@NY"
 * // Using .derived (alias for .computed)
 * state.derived("userCity", ["user.profile.city"], s => s.user.profile.city.toUpperCase());
 * console.log(state.userCity); // "LONDON"
 *
 * // 6. Middleware/interceptors
 * state.use(change => { console.log("Middleware:", change); return change; });
 *
 * // 7. Error handling
 * state.subscribe(() => { throw new Error("fail"); }); // Error is caught and logged
 *
 * // 8. Unsubscribe
 * function onChange(change) { ... }
 * state.subscribe(onChange, "user.name");
 * state.unsubscribe(onChange);
 *
 * // 9. Extensibility
 * // Add persistence, devtools, or TypeScript as needed.
 *
 * ---
 *
 * Nuance:
 * - For object/array state, access properties directly (e.g., state.user.name).
 * - For primitive state (number, string, boolean), use state.value to get/set the value.
 */

/**
 * @typedef {Object} CreateStateOptions
 * @property {boolean} [batch=true] - Enable batched notifications (updates grouped per animation frame)
 */

/**
 * @typedef {Object} SubscribeOptions
 * @property {string|Array&lt;string>} [path] - Property path to subscribe to (dot-notation string or array)
 * @property {boolean} [descendants=false] - If true, subscribe to all descendants of path
 * @property {Function} [selector] - Function to derive a computed value from state (triggers only on value change)
 */

/**
 * Creates a deeply reactive state object with comprehensive change tracking, subscriptions,
 * computed properties, middleware support, and DOM binding capabilities.
 *
 * @function createState
 * @param {Object|Array|string|number|boolean} initialState - Initial state value (object, array, or primitive)
 * @param {CreateStateOptions} [options={}] - Configuration options
 * @param {boolean} [options.batch=true] - Enable batched change notifications for performance
 *
 * @returns {Proxy} Reactive proxy with methods and properties:
 *   - subscribe(fn, options): Subscribe to state changes
 *   - unsubscribe(fn): Remove subscription
 *   - computed(name, deps, fn): Define computed property
 *   - derived(name, deps, fn): Alias for computed()
 *   - use(middleware): Add middleware to intercept changes
 *   - bindToDOM(path, selector, options): Bind state to DOM elements
 *   - undoLast(): Revert to previous state
 *   - redoLast(): Reapply undone changes
 *   - getHistory(): Get change history array
 *   - clearHistory(): Clear history
 *   - suspendHistory(): Pause history recording
 *   - resumeHistory(): Resume history recording
 *   - withoutHistory(fn): Execute function without recording history
 *
 * @example
 * // Object state - access properties directly
 * const state = createState({ user: { name: "Alice", profile: { city: "Paris" } } });
 * state.user.name = "Bob"; // Triggers subscribers
 *
 * @example
 * // Primitive state - use .value property
 * const count = createState(0);
 * count.value = 1; // Triggers subscribers
 *
 * @example
 * // Subscribe to specific path
 * state.subscribe(change => {
 *   console.log("User changed:", change.newValue);
 * }, { path: "user" });
 *
 * @example
 * // Computed properties
 * state.computed("fullInfo", ["user.name", "user.city"], s =>
 *   `${s.user.name} from ${s.user.city}`
 * );
 */
export function createState(initialState, { batch = true } = {}) {
  const HISTORY_KEY = "__uplot_history__";
  let history = [];
  // When true, don't record history (used while applying undo/redo)
  let _suppressHistory = false;
  // Simple redo stack for undone entries
  let _redoStack = [];
  const listeners = new Set();

  // --- Middleware ---
  const middlewares = [];

  // --- Batching ---
  let batchQueue = [];
  let batching = false;
  let rafId = null;

  function notify(change) {
    if (batch) {
      batchQueue.push(change);
      if (!batching) {
        batching = true;
        rafId = requestAnimationFrame(() => {
          const queue = batchQueue;
          batchQueue = [];
          batching = false;
          rafId = null;
          for (const fn of listeners) {
            for (const ch of queue) fn(ch);
          }
        });
      }
    } else {
      for (const fn of listeners) fn(change);
    }
  }

  // Helper: returns true for non-null objects/arrays/Map
  const isObject = (val) => val &amp;&amp; typeof val === "object";
  const isMap = (val) => val instanceof Map;

  // --- Core: Deep reactive Proxy ---
  function createDeepProxy(target, path = []) {
    if (isMap(target)) {
      // Proxy for Map
      return new Proxy(target, {
        get(obj, prop, receiver) {
          if (prop === "__isReactive") return true;
          if (prop === "asArray") {
            // Return array of [key, value] pairs
            return () => Array.from(obj.entries());
          }
          if (["set", "delete", "clear"].includes(prop)) {
            // Wrap mutating methods to notify listeners
            return function (...args) {
              let oldValue, key;
              if (prop === "set") {
                key = args[0];
                oldValue = obj.get(key);
                let value = args[1];
                if (isObject(value) &amp;&amp; !value?.__isReactive) {
                  value = createDeepProxy(value, path.concat([key]));
                  args[1] = value;
                }
                const result = Map.prototype.set.apply(obj, args);
                listeners.forEach((fn) =>
                  fn({
                    path: path.concat([key]),
                    newValue: obj.get(key),
                    oldValue,
                    prop: key,
                    root: proxy,
                  })
                );
                return result;
              } else if (prop === "delete") {
                key = args[0];
                oldValue = obj.get(key);
                const result = Map.prototype.delete.apply(obj, args);
                listeners.forEach((fn) =>
                  fn({
                    path: path.concat([key]),
                    newValue: undefined,
                    oldValue,
                    prop: key,
                    root: proxy,
                  })
                );
                return result;
              } else if (prop === "clear") {
                const oldEntries = Array.from(obj.entries());
                const result = Map.prototype.clear.apply(obj, args);
                oldEntries.forEach(([key, oldValue]) => {
                  listeners.forEach((fn) =>
                    fn({
                      path: path.concat([key]),
                      newValue: undefined,
                      oldValue,
                      prop: key,
                      root: proxy,
                    })
                  );
                });
                return result;
              }
            };
          }
          // For get, has, etc.
          const value = Reflect.get(obj, prop, receiver);
          // Deep-proxy Map values on get
          if (typeof prop === "string" &amp;&amp; obj.has(prop)) {
            const v = obj.get(prop);
            if (isObject(v) &amp;&amp; !v?.__isReactive) {
              const proxied = createDeepProxy(v, path.concat([prop]));
              obj.set(prop, proxied);
              return proxied;
            }
          }
          return value;
        },
      });
    }
    // Proxy for objects/arrays
    return new Proxy(target, {
      set(obj, prop, value) {
        const oldValue = obj[prop];
        // Deep-proxy new object/array/Map values
        if (isObject(value) &amp;&amp; !value?.__isReactive) {
          value = createDeepProxy(value, path.concat(prop));
        }
        obj[prop] = value;
        // Notify all listeners
        listeners.forEach((fn) =>
          fn({
            path: path.concat(prop),
            newValue: value,
            oldValue,
            prop,
            root: proxy,
          })
        );
        return true;
      },
      get(obj, prop) {
        if (prop === "__isReactive") return true;
        if (prop === "asArray") {
          // Return a function that returns a shallow copy of the underlying array if this is an array
          return () => (Array.isArray(obj) ? Array.from(obj) : obj);
        }
        const value = obj[prop];
        // Lazy-proxy nested objects/arrays/Maps
        if (isObject(value) &amp;&amp; !value?.__isReactive) {
          obj[prop] = createDeepProxy(value, path.concat(prop));
          return obj[prop];
        }
        return value;
      },
    });
  }

  // Wrap primitives in an object for consistent Proxying
  const root =
    initialState === null || typeof initialState !== "object"
      ? { value: initialState }
      : initialState;

  const proxy = createDeepProxy(root);

  // --- Advanced Subscription System ---
  /**
   * Subscribe to state changes.
   * @param {function(change)} fn - Called on any set, with {path, newValue, oldValue, prop, root}
   * @param {string|string[]|object} [options] - Optional. Path (string/array), or options object:
   *   { path, descendants, selector, middleware }
   * @returns {void}
   *
   * Example usage:
   *   // Subscribe to all changes
   *   state.subscribe(change => { ... });
   *
   *   // Subscribe to a specific property (string path)
   *   state.subscribe(change => { ... }, 'user.profile.city');
   *
   *   // Subscribe to a path and all descendants
   *   state.subscribe(change => { ... }, { path: 'user.profile', descendants: true });
   *
   *   // Subscribe with a selector
   *   state.subscribe(change => { ... }, { selector: s => s.user.profile.city });
   *
   *   // Unsubscribe
   *   state.unsubscribe(myCallback);
   */
  proxy.subscribe = (fn, options) => {
    let wrapped = fn;
    let pathArr, descendants, selector;
    if (typeof options === "string" || Array.isArray(options)) {
      pathArr = Array.isArray(options) ? options : options.split(".");
    } else if (typeof options === "object" &amp;&amp; options) {
      if (options.path)
        pathArr = Array.isArray(options.path)
          ? options.path
          : options.path.split(".");
      descendants = !!options.descendants;
      selector = options.selector;
    }
    if (pathArr) {
      wrapped = (change) => {
        if (
          (descendants &amp;&amp; pathArr.every((k, i) => k === change.path[i])) ||
          (!descendants &amp;&amp;
            change.path.length === pathArr.length &amp;&amp;
            change.path.every((k, i) => k === pathArr[i]))
        ) {
          try {
            fn(change);
          } catch (e) {
            console.error("Subscriber error:", e);
          }
        }
      };
    } else if (selector) {
      let lastValue = selector(proxy);
      wrapped = (change) => {
        const newValue = selector(proxy);
        if (newValue !== lastValue) {
          lastValue = newValue;
          try {
            fn({ ...change, selectorValue: newValue });
          } catch (e) {
            console.error("Subscriber error:", e);
          }
        }
      };
    } else {
      wrapped = (change) => {
        try {
          fn(change);
        } catch (e) {
          console.error("Subscriber error:", e);
        }
      };
    }
    listeners.add(wrapped);
    fn._wrappedListener = wrapped;
  };

  /**
   * Unsubscribe a listener.
   * @param {function(change)} fn
   */
  proxy.unsubscribe = (fn) => {
    listeners.delete(fn._wrappedListener || fn);
  };

  // --- Batching ---
  function notify(change) {
    if (batch) {
      batchQueue.push(change);
      if (!batching) {
        batching = true;
        rafId = requestAnimationFrame(() => {
          const queue = batchQueue;
          batchQueue = [];
          batching = false;
          rafId = null;
          for (const fn of listeners) {
            for (const ch of queue) fn(ch);
          }
        });
      }
    } else {
      for (const fn of listeners) fn(change);
    }
  }

  // --- Middleware ---
  proxy.use = (mw) => {
    middlewares.push(mw);
  };

  // --- Computed/Derived Properties ---
  proxy.computed = (name, deps, computeFn) => {
    let value = computeFn(proxy);
    Object.defineProperty(proxy, name, {
      get: () => value,
      enumerable: true,
      configurable: true,
    });
    deps.forEach((depPath) => {
      proxy.subscribe(() => {
        value = computeFn(proxy);
      }, depPath);
    });
  };
  // Syntactic sugar: .derived is an alias for .computed
  proxy.derived = proxy.computed;

  // --- Patch Proxy Handlers to use batching and middleware ---
  function applyMiddlewares(change) {
    let ch = change;
    for (const mw of middlewares) {
      ch = mw(ch) || ch;
    }
    return ch;
  }

  // Patch for objects/arrays
  function createDeepProxy(target, path = []) {
    if (isMap(target)) {
      // Proxy for Map
      return new Proxy(target, {
        get(obj, prop, receiver) {
          if (prop === "__isReactive") return true;
          if (prop === "asArray") {
            // Return array of [key, value] pairs
            return () => Array.from(obj.entries());
          }
          if (["set", "delete", "clear"].includes(prop)) {
            // Wrap mutating methods to notify listeners
            return function (...args) {
              let oldValue, key;
              if (prop === "set") {
                key = args[0];
                oldValue = obj.get(key);
                let value = args[1];
                if (isObject(value) &amp;&amp; !value?.__isReactive) {
                  value = createDeepProxy(value, path.concat([key]));
                  args[1] = value;
                }
                const result = Map.prototype.set.apply(obj, args);
                listeners.forEach((fn) =>
                  fn({
                    path: path.concat([key]),
                    newValue: obj.get(key),
                    oldValue,
                    prop: key,
                    root: proxy,
                  })
                );
                return result;
              } else if (prop === "delete") {
                key = args[0];
                oldValue = obj.get(key);
                const result = Map.prototype.delete.apply(obj, args);
                listeners.forEach((fn) =>
                  fn({
                    path: path.concat([key]),
                    newValue: undefined,
                    oldValue,
                    prop: key,
                    root: proxy,
                  })
                );
                return result;
              } else if (prop === "clear") {
                const oldEntries = Array.from(obj.entries());
                const result = Map.prototype.clear.apply(obj, args);
                oldEntries.forEach(([key, oldValue]) => {
                  listeners.forEach((fn) =>
                    fn({
                      path: path.concat([key]),
                      newValue: undefined,
                      oldValue,
                      prop: key,
                      root: proxy,
                    })
                  );
                });
                return result;
              }
            };
          }
          // For get, has, etc.
          const value = Reflect.get(obj, prop, receiver);
          // Deep-proxy Map values on get
          if (typeof prop === "string" &amp;&amp; obj.has(prop)) {
            const v = obj.get(prop);
            if (isObject(v) &amp;&amp; !v?.__isReactive) {
              const proxied = createDeepProxy(v, path.concat([prop]));
              obj.set(prop, proxied);
              return proxied;
            }
          }
          return value;
        },
      });
    }
    // Proxy for objects/arrays
    return new Proxy(target, {
      set(obj, prop, value) {
        const oldValue = obj[prop];
        // Deep-proxy new object/array/Map values
        if (isObject(value) &amp;&amp; !value?.__isReactive) {
          value = createDeepProxy(value, path.concat(prop));
        }
        obj[prop] = value;
        const change = applyMiddlewares({
          path: path.concat(prop),
          newValue: value,
          oldValue,
          prop,
          root: proxy,
        });
        notify(change);
        addHistory(change);
        return true;
      },
      get(obj, prop) {
        if (prop === "__isReactive") return true;
        if (prop === "asArray") {
          // Return a function that returns a shallow copy of the underlying array if this is an array
          return () => (Array.isArray(obj) ? Array.from(obj) : obj);
        }
        const value = obj[prop];
        // Lazy-proxy nested objects/arrays/Maps
        if (isObject(value) &amp;&amp; !value?.__isReactive) {
          obj[prop] = createDeepProxy(value, path.concat(prop));
          return obj[prop];
        }
        return value;
      },
    });
  }

  // --- Flexible DOM Binding API ---
  /**
   * Bind a state property to a DOM property or attribute (one-way or two-way).
   *
   * @param {string|string[]} propertyPath - e.g. 'user.name' or ['user','name']
   * @param {string|Element} selectorOrElement - CSS selector or DOM element
   * @param {Object} options
   *   - {boolean} [twoWay=false]: If true, DOM updates state as well
   *   - {string} [eventType]: Which event to listen for (default: "input" for text, "change" for checkbox/select)
   *   - {string} [prop]: Property of element to bind (e.g. "value", "textContent", "innerHTML")
   *   - {string} [attr]: Attribute of element to bind (e.g. "data-user", "title")
   *   - {boolean} [selectiveUpdate=false]: If true, queue DOM updates on RAF frame (prevents layout thrashing on rapid updates)
   *   - {Object} [selectiveUpdate.queue]: Use external RAF queue (for multi-binding coordination)
   * @returns {Function} Call to unbind listeners
   *
   * @example
   * // Basic one-way binding
   * state.bindToDOM('user.name', '#nameInput');
   *
   * // Two-way binding with RAF update queuing
   * state.bindToDOM('user.name', '#nameInput', {
   *   twoWay: true,
   *   selectiveUpdate: true
   * });
   *
   * // Multiple bindings with shared RAF queue for coordinated updates
   * const updateQueue = createDOMUpdateQueue();
   * state.bindToDOM('prop1', el1, { selectiveUpdate: { queue: updateQueue } });
   * state.bindToDOM('prop2', el2, { selectiveUpdate: { queue: updateQueue } });
   */
  proxy.bindToDOM = function (propertyPath, selectorOrElement, options = {}) {
    let {
      twoWay = false,
      eventType,
      prop,
      attr,
      selectiveUpdate = false,
    } = options;

    // Accept dot, array, or string path
    const pathArr = Array.isArray(propertyPath)
      ? propertyPath
      : typeof propertyPath === "string"
      ? propertyPath.split(".")
      : [propertyPath];

    // Resolve DOM element
    let el =
      typeof selectorOrElement === "string"
        ? document.querySelector(selectorOrElement)
        : selectorOrElement;
    if (!el) {
      console.warn(
        `[createState] bindToDOM: Element not found for selector:`,
        selectorOrElement
      );
      return;
    }

    // Get/set nested property (supports Map)
    function getByPath(obj, path) {
      return path.reduce((o, key) => {
        if (isMap(o)) return o.get(key);
        return o ? o[key] : undefined;
      }, obj);
    }
    function setByPath(obj, path, value) {
      let o = obj;
      for (let i = 0; i &lt; path.length - 1; i++) {
        o = isMap(o) ? o.get(path[i]) : o[path[i]];
      }
      if (isMap(o)) o.set(path[path.length - 1], value);
      else o[path[path.length - 1]] = value;
    }

    // --- DOM update logic ---
    function updateDOM() {
      let value = getByPath(proxy, pathArr);
      if (prop) {
        // Bind to any property (e.g. textContent, innerHTML)
        el[prop] = value ?? "";
      } else if (attr) {
        // Bind to any attribute
        if (value == null) el.removeAttribute(attr);
        else el.setAttribute(attr, value);
      } else if (el.type === "checkbox") {
        el.checked = !!value;
      } else if (
        el.tagName === "INPUT" ||
        el.tagName === "TEXTAREA" ||
        el.tagName === "SELECT"
      ) {
        el.value = value ?? "";
      } else {
        el.textContent = value ?? "";
      }
    }

    // Initialize RAF queue if selectiveUpdate is enabled
    let updateQueue = null;
    if (selectiveUpdate) {
      if (selectiveUpdate.queue) {
        // Use provided external queue for coordination
        updateQueue = selectiveUpdate.queue;
      } else {
        // Try to use global RAF queue from domUpdateQueue utility
        // This is loaded on-demand to keep createState.js lightweight
        try {
          if (typeof window !== "undefined" &amp;&amp; window._domUpdateQueue) {
            updateQueue = window._domUpdateQueue;
          } else {
            console.warn(
              "[createState] selectiveUpdate enabled but domUpdateQueue not initialized globally. Use import { getGlobalDOMUpdateQueue } from './utils/domUpdateQueue.js' to initialize."
            );
            selectiveUpdate = false;
          }
        } catch (e) {
          console.warn(
            "[createState] selectiveUpdate fallback error:",
            e.message
          );
          selectiveUpdate = false;
        }
      }
    }

    updateDOM();

    // Only update if this specific property was changed
    const listener = (change) => {
      if (
        change.path.length === pathArr.length &amp;&amp;
        change.path.every((k, i) => k === pathArr[i])
      ) {
        // Use RAF queue if selectiveUpdate is enabled
        if (
          selectiveUpdate &amp;&amp;
          updateQueue &amp;&amp;
          updateQueue.isActive &amp;&amp;
          updateQueue.isActive()
        ) {
          // Generate unique key for this binding (prevents duplicate updates to same element)
          const dedupeKey = `${
            el.id || el.className || el.tagName
          }_${pathArr.join(".")}`;
          updateQueue.queueUpdate({
            element: el,
            updateFn: updateDOM,
            dedupeKey,
          });
        } else {
          updateDOM();
        }
      }
    };
    proxy.subscribe(listener);

    // --- Two-way binding: DOM â†’ state ---
    if (twoWay) {
      let readProp = prop;
      let evt =
        eventType ||
        (el.type === "checkbox"
          ? "change"
          : el.tagName === "SELECT"
          ? "change"
          : "input");
      const handler = (e) => {
        let val;
        if (attr) {
          val = el.getAttribute(attr);
        } else if (readProp) {
          val = el[readProp];
        } else if (el.type === "checkbox") {
          val = el.checked;
        } else {
          val = el.value;
        }
        setByPath(proxy, pathArr, val);
      };
      el.addEventListener(evt, handler);

      // Unbind both state and DOM listeners, clean up RAF queue reference
      return () => {
        proxy.unsubscribe(listener);
        el.removeEventListener(evt, handler);
        updateQueue = null; // Release reference to allow GC
      };
    } else {
      // Unbind state listener, clean up RAF queue reference
      return () => {
        proxy.unsubscribe(listener);
        updateQueue = null; // Release reference to allow GC
      };
    }
  };

  // --- History Tracking ---

  // Load existing history from localStorage (if any)
  try {
    const saved = localStorage.getItem(HISTORY_KEY);
    if (saved) history = JSON.parse(saved);
  } catch (e) {
    console.warn("[createState] Failed to load history", e);
  }

  // Debounced save to localStorage to avoid blocking the main thread
  let _saveTimer = null;
  function saveHistoryToStorage() {
    if (_saveTimer) clearTimeout(_saveTimer);
    _saveTimer = setTimeout(() => {
      _saveTimer = null;
      try {
        localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
      } catch (e) {
        console.warn("[createState] Failed to save history", e);
      }
    }, 100);
  }

  function detectActionType(change) {
    const pathStr = change.path.join(".");
    if (pathStr.includes("lineColors")) return "color_change";
    if (pathStr.includes("title")) return "title_change";
    if (pathStr.includes("data")) return "data_change";
    if (pathStr.includes("channels")) return "channel_update";
    return "state_update";
  }

  function addHistory(change) {
    // Do not record history while we're applying an undo/redo
    if (_suppressHistory) return;

    // Only record history for changes that affect chart options.
    // This prevents internal API method assignments (subscribe/unsubscribe/etc.)
    // and unrelated state updates from polluting history.
    const relevantKeys = new Set([
      "yLabels",
      "lineColors",
      "yUnits",
      "axesScales",
      "xLabel",
      "xUnit",
      "title",
      "scales",
      "verticalLinesX",
      // include top-level channel groups
      "analog",
      "digital",
    ]);

    const pathMatches = (change.path || []).some((p) => relevantKeys.has(p));
    if (!pathMatches) return; // ignore non-chart-related changes

    const entry = {
      path: change.path,
      oldValue: change.oldValue,
      newValue: change.newValue,
      timestamp: Date.now(),
      actionType: detectActionType(change),
    };
    history.push(entry);
    // New history entry invalidates redo stack
    _redoStack.length = 0;
    saveHistoryToStorage();
  }
  proxy.getHistory = () => [...history];

  proxy.clearHistory = () => {
    history = [];
    saveHistoryToStorage();
  };

  // API helpers to suspend/resume history recording during bulk operations
  proxy.suspendHistory = () => {
    _suppressHistory = true;
  };
  proxy.resumeHistory = () => {
    _suppressHistory = false;
  };
  proxy.withoutHistory = (fn) => {
    const prev = _suppressHistory;
    _suppressHistory = true;
    try {
      return fn();
    } finally {
      _suppressHistory = prev;
    }
  };

  // Apply the last history entry's oldValue (undo)
  proxy.undoLast = () => {
    const last = history.pop();
    if (!last) return;
    // Safely traverse to the parent object for the path
    try {
      let target = proxy;
      for (let i = 0; i &lt; last.path.length - 1; i++) {
        const k = last.path[i];
        if (target == null || typeof target !== "object") {
          // Can't apply undo safely â€” restore history and abort
          history.push(last);
          return;
        }
        target = target[k];
      }
      const key = last.path[last.path.length - 1];
      // Suppress recording while applying undo
      _suppressHistory = true;
      target[key] = last.oldValue;
      _suppressHistory = false;
      // Push into redo stack so the change can be redone later
      _redoStack.push(last);
      saveHistoryToStorage();
    } catch (err) {
      console.error("[createState] undoLast failed:", err);
      try {
        history.push(last);
      } catch (_) {}
    }
  };

  // Redo the most recently undone entry
  proxy.redoLast = () => {
    const entry = _redoStack.pop();
    if (!entry) return;
    try {
      let target = proxy;
      for (let i = 0; i &lt; entry.path.length - 1; i++) {
        const k = entry.path[i];
        if (target == null || typeof target !== "object") {
          _redoStack.push(entry);
          return;
        }
        target = target[k];
      }
      const key = entry.path[entry.path.length - 1];
      _suppressHistory = true;
      target[key] = entry.newValue;
      _suppressHistory = false;
      // Re-add to history (redo is an applied change)
      history.push(entry);
      saveHistoryToStorage();
    } catch (err) {
      console.error("[createState] redoLast failed:", err);
      try {
        _redoStack.push(entry);
      } catch (_) {}
    }
  };

  proxy.getRedoStack = () => [..._redoStack];

  return proxy;
}

// Unwraps a state object or returns the value directly
export function unwrap(valOrState) {
  if (valOrState &amp;&amp; typeof valOrState === "object" &amp;&amp; "value" in valOrState)
    return valOrState.value;
  return valOrState;
}

/*
---------------------
----- EXAMPLES ------
---------------------

// 1. CREATE STATE
const state = createState({
  user: { name: "Alice", info: { city: "LA" } },
  checked: false,
  html: "&lt;b>Hi&lt;/b>",
  settings: new Map([["theme", "light"], ["lang", "en"]])
});

// 2. GET/SET
state.user.name = "Bob";
state.user.info.city = "NY";
console.log(state.user.info.city);

// 3. MAP USAGE
state.settings.set("theme", "dark");
console.log(state.settings.get("theme"));
state.settings.set("profile", { city: "NY" });
state.settings.get("profile").city = "LA"; // Deep reactivity for Map values
state.settings.delete("lang");

// 4. SUBSCRIBE TO ALL CHANGES
state.subscribe(change => {
  console.log("Changed:", change.path.join("."), change.oldValue, "â†’", change.newValue);
});

// 5. DOM BINDING

// &lt;input id="nameInput">   &lt;span id="nameSpan">&lt;/span>
state.bindToDOM('user.name', '#nameInput', { twoWay: true });
state.bindToDOM('user.name', '#nameSpan', { prop: 'textContent' });

// &lt;span id="themeDisplay">&lt;/span>
state.bindToDOM(['settings','theme'], '#themeDisplay', { prop: 'textContent' });

// &lt;div id="profileBox">&lt;/div>
state.bindToDOM(['user','name'], '#profileBox', { attr: 'data-username' });

// &lt;input type="checkbox" id="checkBox">
state.bindToDOM('checked', '#checkBox', { twoWay: true });

// &lt;div id="htmlBox">&lt;/div>
state.bindToDOM('html', '#htmlBox', { prop: 'innerHTML' });

// 6. UNBINDING
const unbind = state.bindToDOM('user.name', '#nameInput', { twoWay: true });
unbind();

*/
</code></pre>
        </article>
    </section>




            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.5</a></p>
                    <p class="sidebar-created-by">
                        <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by
                        <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>


</body>
</html>
