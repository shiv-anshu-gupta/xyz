

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title> components/chartManager - Copy.js</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- build/entry.js removed - not needed -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    Documentation
                </a>
                
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Modules</h3><ul><li><a href="module-Context_ThemeContext.html">Context/ThemeContext</a></li><li><a href="module-analyzeGroupsAndPublish.html">analyzeGroupsAndPublish</a></li><li><a href="module-axisBuilder.html">axisBuilder</a></li><li><a href="module-axisCalculator.html">axisCalculator</a></li><li><a href="module-calculateAndPublishMaxYAxes.html">calculateAndPublishMaxYAxes</a></li><li><a href="module-chartAxisAlignment.html">chartAxisAlignment</a></li><li><a href="module-chartComponent.html">chartComponent</a></li><li><a href="module-chartManager.html">chartManager</a></li><li><a href="module-chartUpdateHelpers.html">chartUpdateHelpers</a></li><li><a href="module-components_AnalysisSidebar.html">components/AnalysisSidebar</a></li><li><a href="module-components_ChannelList.html">components/ChannelList</a></li><li><a href="module-components_ComputedChannelsSidebar.html">components/ComputedChannelsSidebar</a></li><li><a href="module-components_DeltaDrawer.html">components/DeltaDrawer</a></li><li><a href="module-components_DeltaTable.html">components/DeltaTable</a></li><li><a href="module-components_DeltaTableDataFormatter.html">components/DeltaTableDataFormatter</a></li><li><a href="module-components_DeltaTableRenderer.html">components/DeltaTableRenderer</a></li><li><a href="module-components_EquationEvaluatorInChannelList.html">components/EquationEvaluatorInChannelList</a></li><li><a href="module-components_PolarChart.html">components/PolarChart</a></li><li><a href="module-components_PolarChartCanvas.html">components/PolarChartCanvas</a></li><li><a href="module-components_ProgressBar.html">components/ProgressBar</a></li><li><a href="module-components_ResizableGroup.html">components/ResizableGroup</a></li><li><a href="module-components_SidebarResizer.html">components/SidebarResizer</a></li><li><a href="module-components_Tooltip.html">components/Tooltip</a></li><li><a href="module-components_debugPanelLite.html">components/debugPanelLite</a></li><li><a href="module-components_renderComputedChart.html">components/renderComputedChart</a></li><li><a href="module-components_renderComtradeCharts.html">components/renderComtradeCharts</a></li><li><a href="module-components_renderDigitalCharts.html">components/renderDigitalCharts</a></li><li><a href="module-components_renderSingleAnalogChart.html">components/renderSingleAnalogChart</a></li><li><a href="module-components_renderSingleDigitalChart.html">components/renderSingleDigitalChart</a></li><li><a href="module-components_setupPolarChartIntegration.html">components/setupPolarChartIntegration</a></li><li><a href="module-components_showError.html">components/showError</a></li><li><a href="module-components_verticalLineControl.html">components/verticalLineControl</a></li><li><a href="module-comtradeUtils.html">comtradeUtils</a></li><li><a href="module-createDragBar.html">createDragBar</a></li><li><a href="module-createState.html">createState</a></li><li><a href="module-domUpdateQueue.html">domUpdateQueue</a></li><li><a href="module-domUpdateQueueInit.html">domUpdateQueueInit</a></li><li><a href="module-eventListenerManager.html">eventListenerManager</a></li><li><a href="module-handleVerticalLineShortcuts.html">handleVerticalLineShortcuts</a></li><li><a href="module-initVerticalLineControl.html">initVerticalLineControl</a></li><li><a href="module-main.html">main</a></li><li><a href="module-maxYAxesStore.html">maxYAxesStore</a></li><li><a href="module-mergerWindowLauncher.html">mergerWindowLauncher</a></li><li><a href="module-plugins_autoUnitScalePlugin.html">plugins/autoUnitScalePlugin</a></li><li><a href="module-plugins_axisLinesPlugin.html">plugins/axisLinesPlugin</a></li><li><a href="module-plugins_deltaBoxPlugin.html">plugins/deltaBoxPlugin</a></li><li><a href="module-plugins_horizontalZoomPanPlugin.html">plugins/horizontalZoomPanPlugin</a></li><li><a href="module-plugins_verticalLinePlugin.html">plugins/verticalLinePlugin</a></li><li><a href="module-seriesMapper.html">seriesMapper</a></li><li><a href="module-services_computedChannels.html">services/computedChannels</a></li><li><a href="module-services_computedChannels_dataPreparation.html">services/computedChannels/dataPreparation</a></li><li><a href="module-services_computedChannels_eventHandling.html">services/computedChannels/eventHandling</a></li><li><a href="module-services_computedChannels_expressionConversion.html">services/computedChannels/expressionConversion</a></li><li><a href="module-services_computedChannels_resultProcessing.html">services/computedChannels/resultProcessing</a></li><li><a href="module-services_computedChannels_stateUpdate.html">services/computedChannels/stateUpdate</a></li><li><a href="module-services_computedChannels_validators.html">services/computedChannels/validators</a></li><li><a href="module-services_computedChannels_workerManagement.html">services/computedChannels/workerManagement</a></li><li><a href="module-setupChartDragAndDrop.html">setupChartDragAndDrop</a></li><li><a href="module-timeInterpolation.html">timeInterpolation</a></li><li><a href="module-utils_autoGroupChannels.html">utils/autoGroupChannels</a></li><li><a href="module-utils_chartDomUtils.html">utils/chartDomUtils</a></li><li><a href="module-utils_chartMetadataStore.html">utils/chartMetadataStore</a></li><li><a href="module-utils_computedChannelMetadata.html">utils/computedChannelMetadata</a></li><li><a href="module-utils_constants.html">utils/constants</a></li><li><a href="module-utils_helpers.html">utils/helpers</a></li><li><a href="module-utils_sidebarStore.html">utils/sidebarStore</a></li><li><a href="module-workers_computedChannelWorker.html">workers/computedChannelWorker</a></li></ul><h3>Classes</h3><ul><li><a href="module-components_PolarChartCanvas.PolarChartCanvas.html">PolarChartCanvas</a></li><li><a href="module-utils_computedChannelMetadata-ComputedChannelMetadata.html">ComputedChannelMetadata</a></li></ul><h3>Global</h3><ul><li><a href="global.html#IMPLEMENTATION_COMPLETE">IMPLEMENTATION_COMPLETE</a></li><li><a href="global.html#QUICK_REFERENCE">QUICK_REFERENCE</a></li><li><a href="global.html#STORAGE_CFG_KEY">STORAGE_CFG_KEY</a></li><li><a href="global.html#ZOOM_ICONS">ZOOM_ICONS</a></li><li><a href="global.html#adjustMainContent">adjustMainContent</a></li><li><a href="global.html#appendComputedChannelToStorage">appendComputedChannelToStorage</a></li><li><a href="global.html#applyZoom">applyZoom</a></li><li><a href="global.html#attachChartContainer">attachChartContainer</a></li><li><a href="global.html#attachChartEventHandlers">attachChartEventHandlers</a></li><li><a href="global.html#attachChartPlugins">attachChartPlugins</a></li><li><a href="global.html#attachComputedChartContainer">attachComputedChartContainer</a></li><li><a href="global.html#attachComputedChartEventHandlers">attachComputedChartEventHandlers</a></li><li><a href="global.html#attachComputedChartPlugins">attachComputedChartPlugins</a></li><li><a href="global.html#broadcastComputedChannelChange">broadcastComputedChannelChange</a></li><li><a href="global.html#buildChartData">buildChartData</a></li><li><a href="global.html#buildChartOptions">buildChartOptions</a></li><li><a href="global.html#buildComputedChannelLabels">buildComputedChannelLabels</a></li><li><a href="global.html#buildComputedChartOptions">buildComputedChartOptions</a></li><li><a href="global.html#buildGroupsWithAutoGrouping">buildGroupsWithAutoGrouping</a></li><li><a href="global.html#buildGroupsWithUserAssignments">buildGroupsWithUserAssignments</a></li><li><a href="global.html#buildUnitChartData">buildUnitChartData</a></li><li><a href="global.html#calculateStats">calculateStats</a></li><li><a href="global.html#chart2">chart2</a></li><li><a href="global.html#cleanupOldComputedCharts">cleanupOldComputedCharts</a></li><li><a href="global.html#clearChartsContainer">clearChartsContainer</a></li><li><a href="global.html#clearComputedChannelsFromStorage">clearComputedChannelsFromStorage</a></li><li><a href="global.html#clearExpressionCache">clearExpressionCache</a></li><li><a href="global.html#closeAnalysisDrawer">closeAnalysisDrawer</a></li><li><a href="global.html#collectChartDeltas">collectChartDeltas</a></li><li><a href="global.html#computeChartDataDimensions">computeChartDataDimensions</a></li><li><a href="global.html#createBinaryBlob">createBinaryBlob</a></li><li><a href="global.html#createChannelList">createChannelList</a></li><li><a href="global.html#createChartMetadata">createChartMetadata</a></li><li><a href="global.html#createChartOptions">createChartOptions</a></li><li><a href="global.html#createComputedChartMetadata">createComputedChartMetadata</a></li><li><a href="global.html#createComputedClickHandler">createComputedClickHandler</a></li><li><a href="global.html#createComputedMousemoveHandler">createComputedMousemoveHandler</a></li><li><a href="global.html#createDigitalFillPlugin">createDigitalFillPlugin</a></li><li><a href="global.html#createGroupDragBar">createGroupDragBar</a></li><li><a href="global.html#createMousemoveHandler">createMousemoveHandler</a></li><li><a href="global.html#createScopeTemplate">createScopeTemplate</a></li><li><a href="global.html#createState">createState</a></li><li><a href="global.html#createVerticalLineClickHandler">createVerticalLineClickHandler</a></li><li><a href="global.html#createZoomControlsHTML">createZoomControlsHTML</a></li><li><a href="global.html#debounce">debounce</a></li><li><a href="global.html#deleteComputedChannelFromStorage">deleteComputedChannelFromStorage</a></li><li><a href="global.html#encodeFloat64">encodeFloat64</a></li><li><a href="global.html#encodeInt32">encodeInt32</a></li><li><a href="global.html#evaluateExpression">evaluateExpression</a></li><li><a href="global.html#exportAllChannelsAsCSV">exportAllChannelsAsCSV</a></li><li><a href="global.html#exportComputedChannelsAsCSV">exportComputedChannelsAsCSV</a></li><li><a href="global.html#extractChannelMetadata">extractChannelMetadata</a></li><li><a href="global.html#extractChannelNameFromEquation">extractChannelNameFromEquation</a></li><li><a href="global.html#extractGroupId">extractGroupId</a></li><li><a href="global.html#extractMathExpression">extractMathExpression</a></li><li><a href="global.html#filterGroupsWithChannels">filterGroupsWithChannels</a></li><li><a href="global.html#filterUnassignedComputedChannels">filterUnassignedComputedChannels</a></li><li><a href="global.html#filterValidIndices">filterValidIndices</a></li><li><a href="global.html#formatEquationForLatex">formatEquationForLatex</a></li><li><a href="global.html#formatScaledValue">formatScaledValue</a></li><li><a href="global.html#generateCFGContentBinary32">generateCFGContentBinary32</a></li><li><a href="global.html#generateCFGContentBinary64">generateCFGContentBinary64</a></li><li><a href="global.html#generateCFGContentFloat32">generateCFGContentFloat32</a></li><li><a href="global.html#generateCFGContentFloat64">generateCFGContentFloat64</a></li><li><a href="global.html#generateDATContentBinary32">generateDATContentBinary32</a></li><li><a href="global.html#generateDATContentBinary64">generateDATContentBinary64</a></li><li><a href="global.html#generateDATContentFloat32">generateDATContentFloat32</a></li><li><a href="global.html#generateDATContentFloat64">generateDATContentFloat64</a></li><li><a href="global.html#getCacheStats">getCacheStats</a></li><li><a href="global.html#getChannelByDisplayName">getChannelByDisplayName</a></li><li><a href="global.html#getChannelMetadata">getChannelMetadata</a></li><li><a href="global.html#getChannelsForFile">getChannelsForFile</a></li><li><a href="global.html#getCompiledExpression">getCompiledExpression</a></li><li><a href="global.html#getComputedChannelById">getComputedChannelById</a></li><li><a href="global.html#getComputedChannelStorageMetadata">getComputedChannelStorageMetadata</a></li><li><a href="global.html#getComputedChannelsState">getComputedChannelsState</a></li><li><a href="global.html#getElementWidth">getElementWidth</a></li><li><a href="global.html#getFileIndexForTime">getFileIndexForTime</a></li><li><a href="global.html#getOriginalChannelName">getOriginalChannelName</a></li><li><a href="global.html#getSampleIndexInFile">getSampleIndexInFile</a></li><li><a href="global.html#getZoomLevel">getZoomLevel</a></li><li><a href="global.html#groupChannelsByUnit">groupChannelsByUnit</a></li><li><a href="global.html#handleComputedVerticalLineAddition">handleComputedVerticalLineAddition</a></li><li><a href="global.html#handleVerticalLineAddition">handleVerticalLineAddition</a></li><li><a href="global.html#hasStoredComputedChannels">hasStoredComputedChannels</a></li><li><a href="global.html#initComputedChannelsState">initComputedChannelsState</a></li><li><a href="global.html#initializeChartInstance">initializeChartInstance</a></li><li><a href="global.html#initializeComputedChartInstance">initializeComputedChartInstance</a></li><li><a href="global.html#initializeSidebarChannels">initializeSidebarChannels</a></li><li><a href="global.html#initializeZoomControls">initializeZoomControls</a></li><li><a href="global.html#injectZoomControls">injectZoomControls</a></li><li><a href="global.html#isMathJaxLoaded">isMathJaxLoaded</a></li><li><a href="global.html#listenForComputedChannelChanges">listenForComputedChannelChanges</a></li><li><a href="global.html#loadComputedChannelsForGroup">loadComputedChannelsForGroup</a></li><li><a href="global.html#loadComputedChannelsFromStorage">loadComputedChannelsFromStorage</a></li><li><a href="global.html#loadMathJax">loadMathJax</a></li><li><a href="global.html#mathJaxPromise">mathJaxPromise</a></li><li><a href="global.html#measurePerformance">measurePerformance</a></li><li><a href="global.html#mergeAnalogAndComputedMetadata">mergeAnalogAndComputedMetadata</a></li><li><a href="global.html#mergeAnalogChannels">mergeAnalogChannels</a></li><li><a href="global.html#mergeComtradeFilesSetsSequential">mergeComtradeFilesSetsSequential</a></li><li><a href="global.html#mergeDigitalChannels">mergeDigitalChannels</a></li><li><a href="global.html#mergeTimeArraysSequential">mergeTimeArraysSequential</a></li><li><a href="global.html#openAnalysisDrawer">openAnalysisDrawer</a></li><li><a href="global.html#openBothSidebars">openBothSidebars</a></li><li><a href="global.html#openDeltaWindow">openDeltaWindow</a></li><li><a href="global.html#openPhasorDiagram">openPhasorDiagram</a></li><li><a href="global.html#prepareChartDataContext">prepareChartDataContext</a></li><li><a href="global.html#processEquationInput">processEquationInput</a></li><li><a href="global.html#renameChannelWithPrefix">renameChannelWithPrefix</a></li><li><a href="global.html#renderChannelLabelContainer">renderChannelLabelContainer</a></li><li><a href="global.html#renderComputedChannels">renderComputedChannels</a></li><li><a href="global.html#renderLatex">renderLatex</a></li><li><a href="global.html#resetZoom">resetZoom</a></li><li><a href="global.html#resizeChartsToContainers">resizeChartsToContainers</a></li><li><a href="global.html#resolveGroupIndices">resolveGroupIndices</a></li><li><a href="global.html#resolveTimeArray">resolveTimeArray</a></li><li><a href="global.html#saveComputedChannelsToStorage">saveComputedChannelsToStorage</a></li><li><a href="global.html#setZoomLevel">setZoomLevel</a></li><li><a href="global.html#setupMobileSidebar">setupMobileSidebar</a></li><li><a href="global.html#showChannelListWindow">showChannelListWindow</a></li><li><a href="global.html#showFileInfo">showFileInfo</a></li><li><a href="global.html#subscribeChartUpdates">subscribeChartUpdates</a></li><li><a href="global.html#syncComputedChannelsWithParent">syncComputedChannelsWithParent</a></li><li><a href="global.html#toggleChartsVisibility">toggleChartsVisibility</a></li><li><a href="global.html#updateComputedChannelGroupInStorage">updateComputedChannelGroupInStorage</a></li><li><a href="global.html#updateComputedChannelInStorage">updateComputedChannelInStorage</a></li><li><a href="global.html#updateFileInfo">updateFileInfo</a></li><li><a href="global.html#updateMainZoomPosition">updateMainZoomPosition</a></li><li><a href="global.html#updateStatsCards">updateStatsCards</a></li><li><a href="global.html#updateZoomDisplay">updateZoomDisplay</a></li><li><a href="global.html#validateChannelName">validateChannelName</a></li><li><a href="global.html#validateGroupIndices">validateGroupIndices</a></li><li><a href="global.html#wrapChartInSection">wrapChartInSection</a></li><li><a href="global.html#zoomIn">zoomIn</a></li><li><a href="global.html#zoomOut">zoomOut</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>components/chartManager - Copy.js</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * chartManager.js
 *
 * Purpose:
 *   Provides the main chart reactivity and update logic for the COMTRADE charting app.
 *   Handles efficient chart updates in response to state changes (channels, data, overlays).
 *   Integrates with uPlot for fast, interactive chart rendering.
 *
 * Features:
 *   - Subscribes to channel state and data state changes using the custom createState system.
 *   - Updates chart series colors and labels live (without full re-creation) when possible.
 *   - Recreates charts when structural channel changes occur (axes, order, units, etc).
 *   - Recreates charts when data changes (e.g., new file loaded).
 *   - Updates overlays (vertical lines) when their state changes.
 *   - Warns in the console if state/data is missing or malformed.
 *
 * Parameters:
 *   @param {Object} channelState - Reactive state for channel metadata (liabels, colors, units, etc).
 *   @param {Object} dataState    - Reactive state for chart data (analog and digital arrays).
 *   @param {Array}  charts       - Array of uPlot chart instances [analogChart, digitalChart].
 *   @param {HTMLElement} chartsContainer - DOM element containing chart containers.
 *   @param {Object} verticalLinesX - Reactive state for vertical line overlays.
 *
 * Usage Example:
 *   import { subscribeChartUpdates } from './components/chartManager.js';
 *   // ...after initializing state and rendering charts...
 *   subscribeChartUpdates(channelState, dataState, charts, chartsContainer, verticalLinesX);
 *
 *   // Now, any changes to channelState or dataState will automatically update the charts.
 */

import { createChartOptions } from "./chartComponent.js";
// Use global uPlot if loaded via &lt;script> in index.html
const uPlot = window.uPlot;
import { debugLite } from "./debugPanelLite.js";
import { renderComtradeCharts } from "./renderComtradeCharts.js";
/**
 * subscribeChartUpdates(channelState, dataState, charts, chartsContainer, verticalLinesX)
 *
 * Publishes how `chartManager` wires into application state so that JSDoc
 * produces a clear page describing the subscription flow.
 *
 * Responsibilities:
 * - Subscribes to `channelState` and `dataState` reactive stores.
 * - Listens specifically for property-level changes (via `subscribeProperty`) for
 *   fast in-place updates (color, name) and for 'start'/'duration' changes which
 * * are resolved to absolute time windows and applied to uPlot via `applyScale`.
 *
 * Contract (short):
 * - Inputs: `channelState` (see {@link module:message-flow~ChannelStateShape}),
 *   `dataState` (see {@link module:message-flow~DataStateShape}), `charts` array
 *   of uPlot instances, `chartsContainer` parent DOM node, `verticalLinesX` reactive.
 * - Outputs/side-effects: updates uPlot chart instances in-place when possible,
 *   or recreates charts when structural changes occur.
 *
 * Example (flow):
 * ```js
 * // child posts message -> parent main updates channelState -> chartManager resolves
 * // start/duration -> applyScale(chart, type, idx, min, max)
 * ```
 *
 * @param {Object} channelState - reactive channel metadata store
 * @param {Object} dataState - reactive data arrays (time + series)
 * @param {Array} charts - array of uPlot chart instances (analog, digital)
 * @param {HTMLElement} chartsContainer - DOM container for charts
 * @param {Object} verticalLinesX - reactive state for vertical line overlays
 */
export function subscribeChartUpdates(
  channelState,
  dataState,
  charts,
  chartsContainer,
  verticalLinesX,
  cfg, // âœ… add
  data, // âœ… add
  createState, // âœ… add
  calculateDeltas, // âœ… add
  TIME_UNIT // âœ… add
) {
  const chartTypes = ["analog", "digital"];

  function recreateChart(type, idx) {
    if (!channelState[type] || typeof channelState[type] !== "object") {
      console.warn(`channelState[${type}] is undefined or not an object`);
      return;
    }
    if (!Array.isArray(dataState[type])) {
      console.warn(`dataState[${type}] is not an array or is undefined`);
      return;
    }
    if (charts[idx]) {
      charts[idx].destroy();
    }
    const options = createChartOptions(channelState[type], verticalLinesX);
    const data = dataState[type];
    const chart = new uPlot(options, data, chartsContainer.children[idx]);
    charts[idx] = chart;
  }

  // Small helper to force a uPlot chart redraw when setSeries doesn't visually update everything
  function forceRedraw(chart) {
    try {
      // Prefer batch + noop setSize to trigger redraw
      if (!chart) return;
      if (typeof chart.batch === "function") {
        chart.batch(() => {
          try {
            chart.setSize({ width: chart.width, height: chart.height });
          } catch (e) {
            // ignore
          }
        });
      } else {
        try {
          chart.setSize({ width: chart.width, height: chart.height });
        } catch (e) {}
      }
    } catch (e) {
      console.warn("forceRedraw failed", e);
    }
  }

  // --- Boss-style subscription wiring (if channelState exposes subscribeProperty) ---
  // This wires friendly property names (color, name, scale, invert, channelIDs)
  // to uPlot updates or chart recreation so child callbacks update charts directly.
  try {
    if (channelState &amp;&amp; typeof channelState.subscribeProperty === "function") {
      // Fast color updates (attempt in-place, fallback to recreate)
      channelState.subscribeProperty("color", (change) => {
        const type = change.path &amp;&amp; change.path[0];
        const globalIdx = change.path &amp;&amp; change.path[2];
        if (!type) return;
        // Find the chart that contains this global channel index (grouped charts)
        let applied = false;
        for (let ci = 0; ci &lt; charts.length; ci++) {
          const chart = charts[ci];
          if (!chart || chart._type !== type) continue;
          const mapping = chart._channelIndices;
          if (Array.isArray(mapping) &amp;&amp; Number.isFinite(globalIdx)) {
            const pos = mapping.indexOf(globalIdx);
            if (pos >= 0) {
              try {
                if (typeof chart.setSeries === "function") {
                  chart.setSeries(pos + 1, {
                    stroke: change.newValue,
                    points: { stroke: change.newValue },
                  });
                  try {
                    debugLite.log("chart.color", {
                      type,
                      globalIdx,
                      chartIndex: ci,
                      pos,
                      newValue: change.newValue,
                    });
                  } catch (e) {}
                  // Force redraw to ensure any UI that reads chart internals updates
                  try {
                    forceRedraw(chart);
                  } catch (e) {}
                  applied = true;
                }
              } catch (err) {
                console.warn(
                  "chartManager: in-place color update failed on chart",
                  ci,
                  err
                );
              }
            }
          }
        }
        if (applied) return;
        // Fallback: if nothing matched, attempt recreate for all charts of this type
        for (let ci = 0; ci &lt; charts.length; ci++) {
          if (charts[ci] &amp;&amp; charts[ci]._type === type) recreateChart(type, ci);
        }
      });

      // Name/label updates (in-place)
      // Request descendant notifications so we receive per-series changes
      channelState.subscribeProperty(
        "name",
        (change) => {
          const type = change.path &amp;&amp; change.path[0];
          if (!type) return;
          const globalIdx = change.path &amp;&amp; change.path[2];
          try {
            // Whole-array replacement: update labels for each chart based on its mapping
            if (
              change.path &amp;&amp;
              change.path.length === 2 &amp;&amp;
              Array.isArray(change.newValue)
            ) {
              for (let ci = 0; ci &lt; charts.length; ci++) {
                const chart = charts[ci];
                if (!chart || chart._type !== type) continue;
                const mapping = chart._channelIndices || [];
                mapping.forEach((global, pos) => {
                  try {
                    const lbl = change.newValue[global];
                    if (typeof chart.setSeries === "function")
                      chart.setSeries(pos + 1, { label: lbl });
                  } catch (e) {}
                });
                try {
                  debugLite.log("chart.label.array", {
                    type,
                    chartIndex: ci,
                    count: mapping.length,
                  });
                } catch (e) {}
                try {
                  forceRedraw(chart);
                } catch (e) {}
              }
              return;
            }

            // Single-series update: find the chart containing this global index
            if (Number.isFinite(globalIdx)) {
              for (let ci = 0; ci &lt; charts.length; ci++) {
                const chart = charts[ci];
                if (!chart || chart._type !== type) continue;
                const mapping = chart._channelIndices || [];
                const pos = mapping.indexOf(globalIdx);
                if (pos >= 0) {
                  try {
                    if (typeof chart.setSeries === "function")
                      chart.setSeries(pos + 1, { label: change.newValue });
                    try {
                      debugLite.log("chart.label", {
                        type,
                        globalIdx,
                        chartIndex: ci,
                        pos,
                        newValue: change.newValue,
                      });
                    } catch (e) {}
                    try {
                      forceRedraw(chart);
                    } catch (e) {}
                    return;
                  } catch (e) {
                    console.warn(
                      "chartManager: in-place label update failed on chart",
                      ci,
                      e
                    );
                    // continue to next chart
                  }
                }
              }
            }
          } catch (err) {
            console.warn(
              "chartManager: in-place label update failed, recreating charts",
              err
            );
            // Recreate all charts of this type as fallback
            for (let ci = 0; ci &lt; charts.length; ci++) {
              if (charts[ci] &amp;&amp; charts[ci]._type === type)
                recreateChart(type, ci);
            }
          }
        },
        { descendants: true }
      );

      // Structural updates: scale/invert should recreate the chart
      channelState.subscribeProperty(
        "scale",
        (change) => {
          const type = change.path &amp;&amp; change.path[0];
          const typeIdx = chartTypes.indexOf(type);
          if (typeIdx === -1) return;
          recreateChart(type, typeIdx);
        },
        { descendants: true }
      );
      channelState.subscribeProperty(
        "group",
        (change) => {
          try {
            debugLite.log("chart.group.change", change);
          } catch (e) {}
          // Re-render charts with updated grouping
          renderComtradeCharts(
            cfg,
            data,
            chartsContainer,
            charts,
            verticalLinesX,
            createState,
            calculateDeltas,
            TIME_UNIT,
            channelState
          );
        },
        { descendants: true }
      );
      channelState.subscribeProperty(
        "invert",
        (change) => {
          const type = change.path &amp;&amp; change.path[0];
          const typeIdx = chartTypes.indexOf(type);
          if (typeIdx === -1) return;
          recreateChart(type, typeIdx);
        },
        { descendants: true }
      );

      // Add/Delete: channelIDs or yLabels descendant changes -> recreate
      channelState.subscribeProperty(
        "channelIDs",
        (change) => {
          const type = change.path &amp;&amp; change.path[0];
          const typeIdx = chartTypes.indexOf(type);
          if (typeIdx === -1) return;
          recreateChart(type, typeIdx);
        },
        { descendants: true }
      );

      // Start / Duration: prefer setting x scale (time window) when possible
      // Robustness: starts/durations may be provided as sample indices or as timestamps.
      // Use dataState[type][0] (time array) to map indices -> time when necessary.
      function resolveTimeRange(type, seriesIdx) {
        const timeArr =
          Array.isArray(dataState[type]) &amp;&amp; Array.isArray(dataState[type][0])
            ? dataState[type][0]
            : null;
        console.log(`[resolveTimeRange] timeArr for ${type}:`, timeArr);
        // Debug check
        if (!timeArr) {
          console.warn(
            `[resolveTimeRange] Missing or invalid time array for ${type}`
          );
        }

        const starts = channelState[type]?.starts || [];
        const durations = channelState[type]?.durations || [];

        const sRaw = starts[seriesIdx];
        const dRaw = durations[seriesIdx];

        let sNum = sRaw == null ? NaN : Number(sRaw);
        let dNum = dRaw == null ? NaN : Number(dRaw);

        try {
          debugLite.log("resolveTimeRange.request", {
            type,
            seriesIdx,
            sRaw,
            dRaw,
            timeArrLength: timeArr ? timeArr.length : 0,
          });
        } catch (e) {}

        if (Array.isArray(timeArr) &amp;&amp; timeArr.length) {
          const first = timeArr[0];
          const last = timeArr[timeArr.length - 1];
          const totalSamples = timeArr.length;

          // If start is sample index, map to time
          if (Number.isInteger(sNum) &amp;&amp; sNum >= 0 &amp;&amp; sNum &lt; totalSamples) {
            sNum = timeArr[sNum];
          }

          // If duration is sample count, map to time duration
          if (Number.isInteger(dNum) &amp;&amp; dNum > 0 &amp;&amp; dNum &lt; totalSamples) {
            const dt = (last - first) / Math.max(1, totalSamples - 1);
            dNum = dNum * dt;
          }

          // Clamp start/duration
          if (Number.isFinite(sNum)) {
            if (sNum &lt; first) sNum = first;
            if (sNum > last) sNum = last;
          }

          if (Number.isFinite(dNum) &amp;&amp; Number.isFinite(sNum)) {
            if (sNum + dNum > last) dNum = Math.max(0, last - sNum);
          }
        }

        console.log(
          `[resolveTimeRange] type=${type}, seriesIdx=${seriesIdx}, sNum=${sNum}, dNum=${dNum}, hasTime=${!!(
            timeArr &amp;&amp; timeArr.length
          )}`
        );

        return {
          sNum,
          dNum,
          hasTime: Array.isArray(timeArr) &amp;&amp; timeArr.length > 0,
        };
      }

      // Helper: apply x-scale robustly with a cheap redraw and single retry
      function applyScale(chart, type, typeIdx, min, max) {
        try {
          // Attempt immediate apply (batched when possible)
          if (typeof chart.batch === "function") {
            try {
              chart.batch(() => chart.setScale("x", { min, max }));
            } catch (e) {
              chart.setScale("x", { min, max });
            }
          } else {
            chart.setScale("x", { min, max });
          }

          try {
            debugLite.log("subscriber.apply.attempt", { type, min, max });
          } catch (e) {}

          // ðŸ©µ Force re-render after short delay to avoid race with uPlot DOM initialization
          setTimeout(() => {
            try {
              if (chart.setScale) chart.setScale("x", { min, max });
              if (chart.redraw) chart.redraw();
              forceRedraw(chart);
              debugLite.log("subscriber.apply.redraw.ok", { type, min, max });
            } catch (err) {
              debugLite.log("subscriber.apply.redraw.error", { type, err });
            }
          }, 50);

          // schedule a single short retry if needed to work around timing races
          if (!chart._scaleRetryScheduled) {
            chart._scaleRetryScheduled = true;
            setTimeout(() => {
              chart._scaleRetryScheduled = false;
              try {
                if (typeof chart.batch === "function") {
                  chart.batch(() => chart.setScale("x", { min, max }));
                } else {
                  chart.setScale("x", { min, max });
                }
                try {
                  forceRedraw(chart);
                } catch (e) {}
                try {
                  debugLite.log("subscriber.apply.retry", { type, min, max });
                } catch (e) {}
              } catch (err) {
                try {
                  debugLite.log("subscriber.apply.retry.error", { type, err });
                } catch (e) {}
                // fallback to recreate if still failing
                try {
                  debugLite.log("subscriber.apply.retry.fallback", { type });
                } catch (e) {}
                recreateChart(type, typeIdx);
              }
            }, 50);
          }
        } catch (err) {
          try {
            debugLite.log("subscriber.apply.error", { type, err });
          } catch (e) {}
          recreateChart(type, typeIdx);
        }
      }

      // Note: we intentionally do not schedule retries here to avoid extra timers.
      // Initial start/duration application is handled once after initial render
      // by the parent (`main.js`) using a small helper.

      channelState.subscribeProperty(
        "start",
        (change) => {
          const type = change.path &amp;&amp; change.path[0];
          const seriesIdx = change.path &amp;&amp; change.path[2];
          const typeIdx = chartTypes.indexOf(type);
          if (typeIdx === -1) return;
          const chart = charts[typeIdx];
          if (!chart || typeof chart.setScale !== "function") return;
          try {
            try {
              debugLite.log("subscriber.start.received", { change });
            } catch (e) {}
            const { sNum, dNum, hasTime } = resolveTimeRange(type, seriesIdx);
            try {
              debugLite.log("subscriber.start.resolved", {
                type,
                seriesIdx,
                sNum,
                dNum,
                hasTime,
              });
            } catch (e) {}
            if (!hasTime) return;
            if (Number.isFinite(sNum) &amp;&amp; Number.isFinite(dNum)) {
              const min = sNum;
              const max = sNum + dNum;
              applyScale(chart, type, typeIdx, min, max);
            } else if (Number.isFinite(sNum)) {
              const min = sNum;
              applyScale(chart, type, typeIdx, min, null);
            }
          } catch (err) {
            // fallback to full recreate if setScale fails
            try {
              debugLite.log("subscriber.start.fallback.recreate", {
                type,
                err,
              });
            } catch (e) {}
            recreateChart(type, typeIdx);
          }
        },
        { descendants: true }
      );

      channelState.subscribeProperty(
        "duration",
        (change) => {
          const type = change.path &amp;&amp; change.path[0];
          const seriesIdx = change.path &amp;&amp; change.path[2];
          const typeIdx = chartTypes.indexOf(type);
          if (typeIdx === -1) return;
          const chart = charts[typeIdx];
          if (!chart || typeof chart.setScale !== "function") return;
          try {
            try {
              debugLite.log("subscriber.duration.received", { change });
            } catch (e) {}
            const { sNum, dNum, hasTime } = resolveTimeRange(type, seriesIdx);
            try {
              debugLite.log("subscriber.duration.resolved", {
                type,
                seriesIdx,
                sNum,
                dNum,
                hasTime,
              });
            } catch (e) {}
            if (!hasTime) return;
            if (Number.isFinite(sNum) &amp;&amp; Number.isFinite(dNum)) {
              const min = sNum;
              const max = sNum + dNum;
              applyScale(chart, type, typeIdx, min, max);
            } else if (
              Number.isFinite(dNum) &amp;&amp;
              Number.isFinite(sNum) === false
            ) {
              // if duration present but no start, treat as max only (no min)
              const max = dNum;
              applyScale(chart, type, typeIdx, null, max);
            }
          } catch (err) {
            try {
              debugLite.log("subscriber.duration.fallback.recreate", {
                type,
                err,
              });
            } catch (e) {}
            recreateChart(type, typeIdx);
          }
        },
        { descendants: true }
      );
    }
  } catch (e) {
    console.warn("chartManager: subscribeProperty wiring skipped or failed", e);
  }

  // Subscribe to channelState changes
  channelState.subscribe(
    (change) => {
      chartTypes.forEach((type, idx) => {
        // Skip color/label here - those are handled by subscribeProperty to
        // avoid duplicate handling and duplicate debug logs.
        if (
          change.path[0] === type &amp;&amp;
          (change.path[1] === "lineColors" || change.path[1] === "yLabels")
        ) {
          return;
        }

        // Structural changes: axes, order, units, etc.
        if (
          change.path[0] === type &amp;&amp;
          (change.path[1] === "axesScales" ||
            change.path[1] === "order" ||
            change.path[1] === "yUnits" ||
            change.path[1] === "xLabel" ||
            change.path[1] === "xUnit")
        ) {
          recreateChart(type, idx);
          return;
        }
      });
    },
    { descendants: true }
  );

  // Subscribe to data changes (full re-create)
  dataState.subscribe((change) => {
    const type = change.path[0];
    const idx = chartTypes.indexOf(type);
    if (idx !== -1) {
      recreateChart(type, idx);
    }
  });

  // Subscribe to verticalLinesX changes (re-apply overlays)
  verticalLinesX.subscribe(() => {
    chartTypes.forEach((type, idx) => {
      if (charts[idx]) {
        // Assuming you have a function to update vertical lines overlay
        updateVerticalLinesOverlay(charts[idx], verticalLinesX);
      }
    });
  });
}

// Helper: update vertical lines overlay (implement as needed)
function updateVerticalLinesOverlay(chart, verticalLines) {
  // Your logic to update vertical lines on the chart
  // For example, re-draw or update plugin state
}
</code></pre>
        </article>
    </section>




            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.5</a></p>
                    <p class="sidebar-created-by">
                        <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by
                        <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>


</body>
</html>
