<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>COMTRADE Parser Test</title>
    <style>
      body {
        font-family: monospace;
        padding: 20px;
        background: #f5f5f5;
      }
      .test-result {
        padding: 10px;
        margin: 10px 0;
        border-left: 4px solid #999;
        background: white;
      }
      .pass {
        border-color: #4caf50;
        background: #f1f8f6;
      }
      .fail {
        border-color: #f44336;
        background: #fdf0f0;
      }
      h1 {
        color: #333;
      }
      code {
        background: #f0f0f0;
        padding: 2px 5px;
      }
    </style>
  </head>
  <body>
    <h1>COMTRADE 2013 Parser - Module Test</h1>
    <div id="testResults"></div>

    <script type="module">
      import ComtradeFileParser from "./src/utils/fileParser.js";
      import ComtradeCombiner from "./src/utils/combiner.js";

      const results = document.getElementById("testResults");

      function addResult(title, passed, message) {
        const div = document.createElement("div");
        div.className = `test-result ${passed ? "pass" : "fail"}`;
        div.innerHTML = `
        <strong>${passed ? "✅" : "❌"} ${title}</strong>
        <p>${message}</p>
      `;
        results.appendChild(div);
      }

      // Test 1: Module imports
      try {
        addResult(
          "Module Imports",
          true,
          "ComtradeFileParser and ComtradeCombiner imported successfully"
        );
      } catch (e) {
        addResult("Module Imports", false, e.message);
      }

      // Test 2: Parser methods exist
      try {
        const hasParser =
          ComtradeFileParser &&
          typeof ComtradeFileParser.parseCFG === "function" &&
          typeof ComtradeFileParser.parseDAT === "function" &&
          typeof ComtradeFileParser.matchFilePairs === "function";

        addResult(
          "Parser Methods",
          hasParser,
          hasParser
            ? "All parser methods found: parseCFG, parseDAT, matchFilePairs"
            : "Missing one or more parser methods"
        );
      } catch (e) {
        addResult("Parser Methods", false, e.message);
      }

      // Test 3: Combiner methods exist
      try {
        const hasCombiner =
          ComtradeCombiner &&
          typeof ComtradeCombiner.groupByTimeWindow === "function" &&
          typeof ComtradeCombiner.findDuplicateChannels === "function" &&
          typeof ComtradeCombiner.findSimilarChannels === "function";

        addResult(
          "Combiner Methods",
          hasCombiner,
          hasCombiner
            ? "All combiner methods found: groupByTimeWindow, findDuplicateChannels, findSimilarChannels"
            : "Missing one or more combiner methods"
        );
      } catch (e) {
        addResult("Combiner Methods", false, e.message);
      }

      // Test 4: Levenshtein algorithm
      try {
        const distance = ComtradeCombiner.getLevenshteinDistance("IA", "I_A");
        const expected = 1; // One insertion
        const passed = distance === expected;

        addResult(
          "Levenshtein Distance",
          passed,
          `Distance("IA", "I_A") = ${distance} (expected: ${expected})`
        );
      } catch (e) {
        addResult("Levenshtein Distance", false, e.message);
      }

      // Test 5: Time grouping logic
      try {
        const mockData = [
          { timestamp: new Date("2024-12-17T10:00:01"), name: "file1" },
          { timestamp: new Date("2024-12-17T10:00:02"), name: "file2" },
          { timestamp: new Date("2024-12-17T10:00:05"), name: "file3" },
        ];

        const groups = ComtradeCombiner.groupByTimeWindow(mockData, 2.0);
        const passed = groups.length === 2;

        addResult(
          "Time Window Grouping",
          passed,
          `Grouped 3 files with 2s window into ${groups.length} groups (expected: 2)`
        );
      } catch (e) {
        addResult("Time Window Grouping", false, e.message);
      }

      // Test 6: Similarity calculation
      try {
        const ch1 = { name: "IA", unit: "A", type: "analog" };
        const ch2 = { name: "I_A", unit: "A", type: "analog" };

        const similarity = ComtradeCombiner.calculateChannelSimilarity(
          ch1,
          ch2
        );
        const passed = similarity > 0.8 && similarity < 1.0;

        addResult(
          "Channel Similarity",
          passed,
          `Similarity(IA, I_A) = ${(similarity * 100).toFixed(
            1
          )}% (expected: 80-99%)`
        );
      } catch (e) {
        addResult("Channel Similarity", false, e.message);
      }

      // Summary
      const allResults = document.querySelectorAll(".test-result");
      const passCount = document.querySelectorAll(".test-result.pass").length;
      const summary = document.createElement("div");
      summary.style.cssText =
        "margin-top: 20px; padding: 15px; background: #e8f5e9; border: 2px solid #4CAF50; font-weight: bold;";
      summary.innerHTML = `✅ Tests Passed: ${passCount}/${allResults.length}`;
      results.appendChild(summary);

      console.log("COMTRADE Parser Test Suite Complete");
    </script>
  </body>
</html>
